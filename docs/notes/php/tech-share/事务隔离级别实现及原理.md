---
title: 事务隔离级别实现及原理
createTime: 2025/09/15 17:27:43
permalink:  /php/技术分享/0u3adwd99/
---
# 1. 一段话总结

本文围绕MySQL事务展开，重点讲解事务的**ACID四大特性**（原子性、一致性、隔离性、持久性）及实现技术（原子性靠undo log、持久性靠redo log、隔离性靠MVCC或锁机制、一致性由前三者保障），分析了并发事务引发的**脏读、不可重复读、幻读**问题，介绍了SQL标准的**四种隔离级别**（读未提交、读提交、可重复读、串行化），其中MySQL InnoDB默认隔离级别为**可重复读**，并详细阐述了不同隔离级别的实现原理——读未提交直接读最新数据、串行化靠读写锁、读提交和可重复读依赖Read View（读提交每次select生成新Read View，可重复读事务启动时生成Read View并全程使用），还说明了InnoDB在可重复读级别下通过**MVCC（快照读）和next-key lock（当前读）** 大幅避免幻读的方案。

---

# 2. 思维导图（mindmap）

```mindmap
## 一、MySQL事务基础
- 事务定义：保证数据库操作不可分割，要么全成功要么全失败
- 支持引擎：InnoDB支持，MyISAM不支持
- ACID特性
  - 原子性：操作全成或全败，靠undo log实现
  - 一致性：操作前后数据满足完整性约束，靠原子性+持久性+隔离性保障
  - 隔离性：并发事务互不干扰，靠MVCC或锁机制实现
  - 持久性：事务结束后数据修改永久，靠redo log实现
## 二、并发事务问题
- 脏读：读未提交事务修改的数据
- 不可重复读：同一事务内多次读同一数据结果不同
- 幻读：同一事务内多次查符合条件记录数量不同
## 三、事务隔离级别
- 级别分类（从低到高）
  - 读未提交：未提交事务的变更可被其他事务看见，有脏读、不可重复读、幻读
  - 读提交：提交后变更才被其他事务看见，无脏读，有不可重复读、幻读
  - 可重复读：事务内读数据与启动时一致，MySQL InnoDB默认，无脏读、不可重复读，大幅避免幻读
  - 串行化：加读写锁，无脏读、不可重复读、幻读，性能低
- 各级别下查询结果示例（以账户余额100万，事务A查、事务B改200万为例）
  - 读未提交：A的V1、V2、V3均为200万
  - 读提交：A的V1为100万，V2、V3为200万
  - 可重复读：A的V1、V2为100万，V3为200万
  - 串行化：A的V1、V2为100万，V3为200万
## 四、隔离级别实现原理
- 读未提交：直接读取最新数据
- 串行化：通过读写锁避免并行访问，读写冲突时后事务等待
- 读提交&可重复读：依赖Read View
  - Read View组成：m_ids（活跃事务ID列表）、min_trx_id（活跃事务最小ID）、max_trx_id（下一个事务ID）、creator_trx_id（创建者事务ID）
  - 记录隐藏列：trx_id（修改事务ID）、roll_pointer（指向旧版本undo log）
  - 可见性判断规则：trx_id<min_trx_id→可见；trx_id≥max_trx_id→不可见；介于两者间则看是否在m_ids（在→不可见，不在→可见）
  - 区别：读提交每次select生成新Read View；可重复读事务启动时生成Read View并全程使用
## 五、可重复读级别避免幻读方案
- 快照读（普通select）：靠MVCC，事务内读数据与启动时一致，查不到其他事务插入数据
- 当前读（select ... for update等）：靠next-key lock（记录锁+间隙锁），阻塞锁范围内插入操作
```

---

# 3. 详细总结

## 一、事务基础：定义、支持引擎与ACID特性

1. **事务定义**：确保数据库操作（如转账的多步修改）不可分割，要么全部执行成功，要么全部失败，避免中间状态数据（如转账时一方扣钱另一方未到账）。
2. **支持引擎**：仅InnoDB引擎支持事务，MySQL原生的MyISAM引擎不支持，因此InnoDB是主流选择。
3. **ACID四大特性**：事务实现需遵守的核心原则，各特性及实现技术如下表：
| 特性（英文）                    | 核心含义                                                                   | 实现技术                                             |
   | ------------------------------- | -------------------------------------------------------------------------- | ---------------------------------------------------- |
   | **原子性（Atomicity）**   | 一个事务内所有操作，要么全完成，要么全不完成；执行中出错则回滚到事务前状态 | **undo log（回滚日志）**                       |
   | **一致性（Consistency）** | 事务操作前后，数据满足完整性约束（如转账前后总金额不变）                   | 原子性+持久性+隔离性共同保障                         |
   | **隔离性（Isolation）**   | 多个并发事务同时读写数据时，互不干扰，每个事务有独立数据空间               | **MVCC（多版本并发控制）** 或 **锁机制** |
   | **持久性（Durability）**  | 事务处理结束后，对数据的修改永久生效，即使系统故障也不丢失                 | **redo log（重做日志）**                       |

## 二、并发事务引发的三大问题

当MySQL同时处理多个事务时，可能出现以下数据一致性问题，均通过示例说明：

1. **脏读（Dirty Read）**
   - 定义：一个事务读到另一个**未提交事务修改过的数据**。
   - 示例：事务A读取小林余额100万后更新为200万（未提交），事务B此时读取到200万；若事务A后续回滚，事务B读到的200万就是无效的“脏数据”。
2. **不可重复读（Non-repeatable Read）**
   - 定义：在一个事务内，多次读取同一个数据，前后两次读到的数据不一致。
   - 示例：事务A首次读取小林余额100万，事务B更新该余额为200万并提交，事务A再次读取时，余额变为200万，与首次读取结果不同。
3. **幻读（Phantom Read）**
   - 定义：在一个事务内，多次查询符合条件的**记录数量**，前后两次查询结果不同。
   - 示例：事务A首次查询余额>100万的记录有5条，事务B插入一条余额>100万的记录并提交，事务A再次查询时，记录数量变为6条，如同产生“幻觉”。

## 三、事务的四种隔离级别

SQL标准提出四种隔离级别，用于规避上述并发问题，隔离级别越高，数据一致性越好，但性能越低。各级别详情如下：

### 1. 级别分类与并发问题规避情况

| 隔离级别                               | 隔离级别高低 | 可规避的问题           | 不可规避的问题             |
| -------------------------------------- | ------------ | ---------------------- | -------------------------- |
| **读未提交（Read Uncommitted）** | 最低         | -                      | 脏读、不可重复读、幻读     |
| **读提交（Read Committed）**     | 较低         | 脏读                   | 不可重复读、幻读           |
| **可重复读（Repeatable Read）**  | 较高         | 脏读、不可重复读       | 大幅避免幻读（非完全避免） |
| **串行化（Serializable）**       | 最高         | 脏读、不可重复读、幻读 | -                          |

- 注：MySQL InnoDB引擎的**默认隔离级别是可重复读**，且对幻读有优化方案（见下文）。

### 2. 各隔离级别下的查询结果示例

假设有账户余额表（初始余额100万），两个并发事务：事务A仅查询余额，事务B将余额改为200万，执行顺序如下表，不同隔离级别下事务A的查询结果（V1、V2、V3）不同：

| 执行步骤 | 事务A操作               | 事务B操作                  |
| -------- | ----------------------- | -------------------------- |
| 1        | 启动事务A，查询余额→V1 | -                          |
| 2        | -                       | 启动事务B，查询余额→100万 |
| 3        | -                       | 将余额改为200万            |
| 4        | 查询余额→V2            | -                          |
| 5        | -                       | 提交事务B                  |
| 6        | 查询余额→V3            | -                          |
| 7        | 提交事务A               | -                          |

各隔离级别下事务A的查询结果：

| 隔离级别 | V1（步骤1） | V2（步骤4） | V3（步骤6） |
| -------- | ----------- | ----------- | ----------- |
| 读未提交 | 200万       | 200万       | 200万       |
| 读提交   | 100万       | 100万       | 200万       |
| 可重复读 | 100万       | 100万       | 100万       |
| 串行化   | 100万       | 100万       | 100万       |

- 说明：串行化级别下，事务B修改余额时因事务A已读操作产生读写冲突，需等待事务A提交后才能执行，故事务A提交前查询结果均为100万。

## 四、隔离级别的实现原理

不同隔离级别通过不同机制实现，核心差异集中在“如何控制数据可见性”：

1. **读未提交**：最简单的实现，直接读取数据库中最新的数据，无需额外控制，因此能读到未提交事务的修改。
2. **串行化**：通过**读写锁**实现，对操作的记录加锁。当多个事务读写同一记录时，若发生读写冲突，后访问的事务必须等待前一个事务执行完成才能继续，完全避免并发问题，但会大幅降低性能。
3. **读提交与可重复读**：均通过**Read View（数据快照）** 实现，核心是通过Read View判断数据版本的可见性，两者的关键区别是**创建Read View的时机不同**：
   - **Read View组成**：包含4个核心字段，用于判断数据版本是否可见：
     - `m_ids`：创建Read View时，数据库中**活跃且未提交**的事务ID列表；
     - `min_trx_id`：`m_ids`中的最小事务ID；
     - `max_trx_id`：创建Read View时，数据库“下一个要分配的事务ID”（非 `m_ids`的最大值，而是全局最大事务ID+1）；
     - `creator_trx_id`：创建该Read View的事务ID。
   - **数据版本判断依据**：InnoDB的聚簇索引记录包含两个隐藏列，结合Read View判断可见性：
     - `trx_id`：修改该记录的事务ID；
     - `roll_pointer`：指针，指向该记录修改前的旧版本（存储在undo log中，形成版本链）。
   - **可见性规则**：
     1. 若记录的 `trx_id` < Read View的 `min_trx_id`：该版本由Read View创建前已提交的事务生成，**可见**；
     2. 若记录的 `trx_id` ≥ Read View的 `max_trx_id`：该版本由Read View创建后启动的事务生成，**不可见**；
     3. 若记录的 `trx_id`在 `min_trx_id`和 `max_trx_id`之间：
        - 若 `trx_id`在 `m_ids`列表中：生成该版本的事务仍活跃（未提交），**不可见**；
        - 若 `trx_id`不在 `m_ids`列表中：生成该版本的事务已提交，**可见**。
   - **两者差异**：
     - **读提交**：在**每个select语句执行前**，重新生成一个Read View，因此同一事务内多次select可能看到不同版本的数据（若期间有其他事务提交修改）；
     - **可重复读**：在**事务启动时**生成一个Read View，整个事务期间都使用这个Read View，因此同一事务内多次select看到的数据与事务启动时一致，实现“可重复读”。

## 五、可重复读级别下避免幻读的方案

MySQL InnoDB在默认的可重复读级别下，通过两种方案大幅避免幻读，覆盖不同的读取场景：

1. **针对快照读（普通select语句）**：通过**MVCC（多版本并发控制）** 实现
   - 原理：快照读基于事务启动时创建的Read View，读取的是数据的历史版本（通过undo log的版本链获取）。即使其他事务插入新记录并提交，该新记录的 `trx_id`会大于当前事务Read View的 `max_trx_id`，根据可见性规则判定为“不可见”，因此查询不到新记录，避免幻读。
2. **针对当前读（如select ... for update、update、delete等语句）**：通过**next-key lock（记录锁+间隙锁）** 实现
   - 原理：当前读需要获取数据的最新版本，执行时会对查询范围加“next-key lock”——既锁定具体的记录（记录锁），也锁定记录之间的间隙（间隙锁）。若其他事务试图在该锁范围内插入新记录，会被阻塞，无法成功插入，从而避免“插入新记录导致幻读”的情况。

## 六、关键补充：MySQL事务启动时机

MySQL有两种开启事务的命令，启动时机不同：

1. `begin/start transaction`：执行该命令后，事务并未立即启动，**只有执行第一条select语句时，事务才真正启动**；
2. `start transaction with consistent snapshot`：执行该命令后，事务**立即启动**，并同时生成Read View（适用于可重复读级别）。

---

# 4. 关键问题与答案

## 问题1：MySQL InnoDB引擎的默认隔离级别是“可重复读”，它如何大幅避免幻读？分别针对什么读取场景？

### 答案：

InnoDB在可重复读级别下，通过两种方案分别针对“快照读”和“当前读”场景大幅避免幻读，具体如下：

1. **针对快照读（普通select语句）**：通过**MVCC（多版本并发控制）** 实现。快照读基于事务启动时创建的Read View（数据快照），读取的是数据的历史版本（通过undo log的版本链获取）。即使其他事务插入新记录并提交，新记录的 `trx_id`会大于当前事务Read View的 `max_trx_id`，根据可见性规则判定为“不可见”，因此查询不到新记录，避免幻读。
2. **针对当前读（如select ... for update、update、delete语句）**：通过**next-key lock（记录锁+间隙锁）** 实现。
   当前读需获取最新数据，执行时会对查询范围加“next-key lock”——既锁定具体记录（防止修改/删除），也锁定记录间的间隙（防止插入新记录）。其他事务若在锁范围内插入新记录，会被阻塞，无法成功插入，从而避免幻读。

## 问题2：“读提交”和“可重复读”隔离级别均通过Read View实现，两者的核心区别是什么？请结合示例说明该区别导致的查询结果差异。

### 答案：

两者的核心区别是**创建Read View的时机不同**：读提交在“每次select语句执行前重新生成Read View”，可重复读在“事务启动时生成Read View，且整个事务期间复用该Read View”。该区别导致同一事务内多次读取同一数据的结果可能不同，示例如下：

#### 示例场景：

- 初始数据：账户表中小林余额100万；
- 事务A（仅查询余额）和事务B（修改余额为200万）并发执行，步骤如下：
  1. 事务A启动，首次查询余额→结果1；
  2. 事务B启动，将余额改为200万并提交；
  3. 事务A再次查询余额→结果2。

#### 不同隔离级别下的查询结果：

1. **读提交级别**：

   - 事务A首次查询（步骤1）：生成Read View1，此时无活跃事务修改余额，读取到100万（结果1=100万）；
   - 事务B提交后，事务A再次查询（步骤3）：重新生成Read View2，此时事务B已提交，其修改的200万版本可见，读取到200万（结果2=200万）；
   - 结果差异：同一事务内两次查询结果不同（100万→200万）。
2. **可重复读级别**：

   - 事务A启动时生成Read View（全程复用），步骤1查询时基于该Read View读取到100万（结果1=100万）；
   - 步骤3再次查询时，仍使用启动时的Read View，事务B提交的200万版本因 `trx_id`大于Read View的 `max_trx_id`而不可见，读取到100万（结果2=100万）；
   - 结果差异：同一事务内两次查询结果一致（均为100万）。

## 问题3：事务的ACID特性中，原子性和持久性分别通过InnoDB的什么技术实现？请简要说明其实现逻辑。

### 答案：

- **原子性（Atomicity）**：通过**undo log（回滚日志）** 实现，逻辑如下：当事务执行修改操作（如update、delete、insert）时，InnoDB会先将修改前的数据（或修改的反向操作）记录到undo log中。若事务执行过程中发生错误（如服务器掉电、SQL报错）或用户执行 `rollback`，InnoDB会通过undo log中的记录，将数据“回滚”到事务执行前的状态，确保事务内所有操作要么全完成，要么全不完成，满足原子性。
- **持久性（Durability）**：通过**redo log（重做日志）** 实现，逻辑如下：
  InnoDB采用“WAL（Write-Ahead Logging）”机制，即事务执行修改操作时，先将修改的“物理日志”（如“将某页某位置的数据从100改为200”）写入redo log（redo log写入后会刷盘，确保不丢失），再将修改应用到内存中的数据页。即使系统故障（如掉电），重启后InnoDB可通过redo log，重新执行日志中记录的修改操作，将数据恢复到故障前的状态，保证事务结束后数据修改永久生效，满足持久性。
