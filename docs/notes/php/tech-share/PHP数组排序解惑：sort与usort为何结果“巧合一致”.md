---
title: PHP数组排序解惑：sort与usort为何结果“巧合一致”
createTime: 2025/11/27 06:40:13
permalink: /php/技术分享/h29mzo1m/
---

# PHP多维数组排序：为什么sort和usort结果有时“撞车”？


在PHP开发中，多维数组排序是高频需求——比如处理商品列表时按`id`排序、统计数据时按`数量`排序。但你可能遇到过一个有趣的现象：用默认的`sort()`和自定义的`usort()`排序，结果居然一模一样？这是不是意味着两者可以混用？今天我们就拆解这个“巧合”，搞懂背后的逻辑差异。


## 一、先理清基础：sort()与usort()的核心区别
在分析“结果一致”之前，必须先明确两个函数的本质——它们的排序逻辑完全不同，只是在特定场景下“殊途同归”。

| 特性                | `sort()`                          | `usort()`                          |
|---------------------|-----------------------------------|------------------------------------|
| **排序逻辑来源**    | PHP内置的默认值比较规则           | 用户自定义的回调函数               |
| **可控性**          | 不可控（依赖PHP规则）             | 完全可控（按需求定义排序字段/规则） |
| **适用场景**        | 一维简单数组（如`[1,3,2]`）       | 多维数组/需按指定字段排序的场景    |
| **是否保留键名**    | 重置为数字索引（破坏原键名）      | 重置为数字索引（需保留键名用`uasort()`） |


举个直观的例子，假设我们有这样一个多维数组（需按`id`排序）：
```php
$items = [
    ['id' => 3, 'quantity' => 10],
    ['id' => 2, 'quantity' => 10],
];
```

- 用`sort($items)`排序，结果是`id=2`在前、`id=3`在后；
- 用`usort($items, function($a, $b) { return $a['id'] - $b['id']; })`排序，结果也一样。

看起来没区别？但这只是“巧合”，我们接着往下拆。


## 二、关键：PHP如何比较两个关联数组？
`sort()`能让结果“对”，核心是它遵循了PHP内置的**关联数组比较规则**——这个规则恰好和我们自定义的“按`id`排序”撞车了。

PHP比较两个关联数组时，会按以下步骤执行：
1. **第一步：比较元素个数**  
   如果A数组有2个元素，B数组有3个元素，直接判定A < B（元素少的更小）。
2. **第二步：按键名的字母顺序比较对应值**  
   若元素个数相同，会按键名的字母顺序（a-z）逐个对比对应的值：  
   - 先找第一个共同的键名（按字母排序），比较该键名下的两个值；
   - 若值相等，再找下一个共同键名继续比较；
   - 若所有共同键名的值都相等，才判定两个数组相等。


回到我们的示例数组：
两个子数组的结构完全一致——都是2个元素，键名都是`id`和`quantity`。  
按字母顺序，`id`（首字母`i`）排在`quantity`（首字母`q`）前面，所以PHP会**优先比较`id`的值**：
- 第一个子数组`id=3`，第二个`id=2` → 3 > 2 → `sort()`自动把`id=2`的子数组放到前面。

这就和我们自定义的`usort($a['id'] - $b['id'])`规则（`id`小的排前面）完全一致，最终结果自然“撞车”。


## 三、打破“巧合”：换个场景，差异立显
一旦数组结构或数据发生变化，`sort()`的“不可控性”就会暴露，而`usort()`始终能按我们的预期工作。我们用两个案例验证：


### 案例1：键名顺序调换
如果子数组的键名顺序反过来（`quantity`在前，`id`在后）：
```php
$items = [
    ['quantity' => 10, 'id' => 3], // 键名顺序：quantity → id
    ['quantity' => 10, 'id' => 2],
];

// 用sort()排序
sort($items);
var_dump($items); 
// 结果：id=2在前（因为仍先比id，键名顺序不影响字母排序）

// 看似结果还对？再看案例2
```


### 案例2：quantity值不同
如果`quantity`的值不一样，`sort()`的逻辑就会“跑偏”：
```php
$items = [
    ['quantity' => 20,'id' => 2], // id小，但quantity大
    ['quantity' => 10,'id' => 3], // id大，但quantity小
];

// 1. 用sort()排序
sort($items);
var_dump($items); 
// 结果：[['quantity'=>10,'id'=>3], ['quantity'=>20,'id'=>2]]
// 原因：按键名字母顺序，先比quantity（10 < 20），直接判定id=3的数组更小


// 2. 用usort()排序（按id）
usort($items, function($a, $b) {
    return $a['id'] - $b['id'];
});
var_dump($items); 
// 结果：[['quantity'=>20,'id'=>2], ['quantity'=>10,'id'=>3]]
// 原因：严格按id比较，不受quantity影响
```

这个案例清晰地说明：`sort()`的结果依赖PHP默认规则，而`usort()`的结果完全由我们定义——这才是开发中需要的“稳定性”。


## 四、开发实践建议：别再用sort()处理多维数组！
通过上面的分析，我们可以得出明确的实践结论：

1. **一维简单数组→用sort()**  
   比如排序`[5,2,8]`或`['apple', 'banana', 'cherry']`，`sort()`足够高效简洁。

2. **多维数组→必须用自定义排序**  
   - 按指定字段排序（如`id`、`price`）：用`usort()`；
   - 排序后需保留原键名（如关联数组的自定义键）：用`uasort()`；
   - 按数组的键名排序（而非值）：用`uksort()`。

3. **回调函数的灵活写法**  
   PHP 7+支持太空船运算符（`<=>`），能简化回调函数逻辑，比如按`id`升序：
   ```php
   usort($items, function($a, $b) {
       return $a['id'] <=> $b['id']; // 等价于 $a['id'] - $b['id']
   });
   // 降序则反过来：return $b['id'] <=> $a['id'];
   ```


## 五、总结
- **“结果一致”是巧合**：`sort()`和`usort()`结果相同，只是因为PHP默认的数组比较规则恰好先比较了`id`，并非两者逻辑一致；
- **本质差异是可控性**：`sort()`依赖PHP规则（不可控），`usort()`依赖自定义逻辑（可控）；
- **开发核心原则**：处理多维数组排序时，永远用`usort()`/`uasort()`等自定义排序函数，避免因PHP默认规则导致的潜在bug。

