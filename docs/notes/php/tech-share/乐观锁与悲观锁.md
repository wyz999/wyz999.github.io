---
title: 乐观锁与悲观锁
createTime: 2025/09/15 17:27:43
permalink: /php/技术分享/0u3pm2zq/
---

# 乐观锁与悲观锁：原理解析及webman环境下的实践场景


## 一、核心原理与特性对比

乐观锁和悲观锁是并发编程中解决数据一致性问题的两种核心思想，其设计理念和适用场景存在显著差异，理解两者的本质是正确应用的前提。


### 1. 核心思想
- **悲观锁**：假设并发冲突会频繁发生，因此在操作数据时主动加锁，阻止其他线程对数据的修改，直到当前操作完成并释放锁。核心是“先上锁，再操作”，通过独占资源避免冲突。
- **乐观锁**：假设并发冲突很少发生，因此操作数据时不主动加锁，仅在最终提交更新时检查数据是否被修改。核心是“先操作，再校验”，通过版本校验解决冲突。


### 2. 实现方式
- **悲观锁**：
  - 数据库层面：利用`SELECT ... FOR UPDATE`（行锁）、表锁等数据库原生锁机制，强制并发操作串行化。
  - 框架层面：在webman等PHP框架中，通过ORM的`lockForUpdate()`方法实现行锁，需配合事务使用。

- **乐观锁**：
  - 版本号机制：在数据表中添加`version`字段，读取数据时获取版本号，更新时校验版本号是否一致（一致则更新并递增版本号，否则失败）。
  - 时间戳机制：通过`update_time`等时间戳字段替代版本号，原理与版本号机制一致。


### 3. 优缺点对比
| 维度         | 悲观锁                     | 乐观锁                     |
|--------------|----------------------------|----------------------------|
| **并发性能** | 差，加锁会阻塞其他操作，可能导致锁竞争和超时 | 好，无锁阻塞，适合高并发场景 |
| **冲突处理** | 提前避免冲突，操作成功率高 | 冲突发生后检测，可能需要重试 |
| **适用场景** | 写操作频繁、冲突概率高、一致性要求极高的场景 | 读操作频繁、冲突概率低的场景 |
| **实现复杂度** | 简单，依赖数据库或框架锁机制 | 较复杂，需手动实现版本校验和重试逻辑 |


## 二、webman环境下的实践场景

webman基于Workerman实现多进程异步处理，并发场景下的数据一致性问题更突出。以下结合典型业务场景，说明两种锁的具体应用。


### 场景1：电商商品库存扣减
**业务背景**：处理用户抢购商品（如秒杀、促销），需防止库存超卖。

- **悲观锁实现**：  
  适合库存紧张、并发抢购频繁的场景（如秒杀）。通过行锁强制串行处理库存扣减，确保同一时间只有一个进程能修改库存。
  ```php
  public function seckill($goodsId, $userId) {
      $db = Db::connection();
      try {
          $db->beginTransaction();
          // 锁定商品行（行锁生效需在事务中）
          $goods = Goods::where('id', $goodsId)->lockForUpdate()->first();
          if (!$goods || $goods->stock <= 0) {
              $db->rollBack();
              return json(['code' => 0, 'msg' => '库存不足']);
          }
          // 扣减库存
          $goods->stock -= 1;
          $goods->save();
          // 创建订单（省略逻辑）
          $db->commit();
          return json(['code' => 1, 'msg' => '抢购成功']);
      } catch (\Exception $e) {
          $db->rollBack();
          return json(['code' => 0, 'msg' => '抢购失败']);
      }
  }
  ```

- **乐观锁实现**：  
  适合库存充足、冲突概率低的场景（如普通商品购买）。通过版本号允许并发读取，仅在提交时校验库存是否被修改。
  ```php
  public function seckill($goodsId, $userId) {
      $loop = 3; // 最多重试3次
      while ($loop-- > 0) {
          $goods = Goods::find($goodsId);
          if (!$goods || $goods->stock <= 0) {
              return json(['code' => 0, 'msg' => '库存不足']);
          }
          // 带版本号更新库存
          $rows = Goods::where(['id' => $goodsId, 'version' => $goods->version])
              ->update(['stock' => $goods->stock - 1, 'version' => $goods->version + 1]);
          if ($rows > 0) {
              // 创建订单（省略逻辑）
              return json(['code' => 1, 'msg' => '抢购成功']);
          }
      }
      return json(['code' => 0, 'msg' => '抢购失败，请重试']);
  }
  ```


### 场景2：用户余额支付
**业务背景**：用户同时进行多笔消费（如购物+充值会员），需保证余额不超支。

- **悲观锁实现**：  
  适合金融场景等对一致性要求极高的场景。锁定用户余额记录，确保扣减操作的原子性。
  ```php
  public function pay($userId, $amount) {
      $db = Db::connection();
      try {
          $db->beginTransaction();
          // 锁定用户余额行
          $account = UserAccount::where('user_id', $userId)->lockForUpdate()->first();
          if (!$account || $account->balance < $amount) {
              $db->rollBack();
              return json(['code' => 0, 'msg' => '余额不足']);
          }
          // 扣减余额
          $account->balance -= $amount;
          $account->save();
          $db->commit();
          return json(['code' => 1, 'msg' => '支付成功']);
      } catch (\Exception $e) {
          $db->rollBack();
          return json(['code' => 0, 'msg' => '支付失败']);
      }
  }
  ```

- **乐观锁实现**：  
  适合普通消费场景（如电商购物），冲突概率低。通过版本号校验避免并发超支。
  ```php
  public function pay($userId, $amount) {
      $loop = 3;
      while ($loop-- > 0) {
          $account = UserAccount::where('user_id', $userId)->first();
          if (!$account || $account->balance < $amount) {
              return json(['code' => 0, 'msg' => '余额不足']);
          }
          // 带版本号更新余额
          $rows = UserAccount::where(['user_id' => $userId, 'version' => $account->version])
              ->update(['balance' => $account->balance - $amount, 'version' => $account->version + 1]);
          if ($rows > 0) {
              return json(['code' => 1, 'msg' => '支付成功']);
          }
      }
      return json(['code' => 0, 'msg' => '支付失败，请重试']);
  }
  ```


### 场景3：订单状态更新
**业务背景**：异步处理订单支付回调（如webman的task任务），需防止同一订单被重复处理。

- **悲观锁实现**：  
  适合订单状态必须唯一的场景（如支付结果回调）。锁定订单记录，确保状态更新的唯一性。
  ```php
  // webman异步任务处理订单回调
  public function handle($orderId) {
      $db = Db::connection();
      try {
          $db->beginTransaction();
          // 锁定订单行
          $order = Order::where('id', $orderId)->lockForUpdate()->first();
          if (!$order || $order->status != 'pending') {
              $db->rollBack();
              return '订单已处理';
          }
          // 更新状态为“已支付”
          $order->status = 'paid';
          $order->save();
          $db->commit();
          return '订单处理成功';
      } catch (\Exception $e) {
          $db->rollBack();
          return '处理失败';
      }
  }
  ```

- **乐观锁实现**：  
  适合回调频率不高的场景。通过版本号判断订单是否被其他进程修改，避免重复处理。
  ```php
  public function handle($orderId) {
      $loop = 2;
      while ($loop-- > 0) {
          $order = Order::find($orderId);
          if (!$order || $order->status != 'pending') {
              return '订单已处理';
          }
          // 带版本号更新状态
          $rows = Order::where(['id' => $orderId, 'version' => $order->version, 'status' => 'pending'])
              ->update(['status' => 'paid', 'version' => $order->version + 1]);
          if ($rows > 0) {
              return '订单处理成功';
          }
      }
      return '处理失败';
  }
  ```


## 三、锁选择原则与最佳实践

在webman环境中，选择乐观锁还是悲观锁需结合业务特性：

1. **冲突频率**：冲突频繁（如秒杀、金融交易）选悲观锁；冲突稀少（如普通商品购买）选乐观锁。
2. **一致性要求**：强一致性场景（如余额支付）选悲观锁；可接受短暂重试的场景（如订单状态更新）选乐观锁。
3. **性能需求**：高并发场景优先考虑乐观锁（无锁阻塞）；低并发场景可简化逻辑使用悲观锁。
4. **实现细节**：
   - 悲观锁需注意缩小事务范围，避免长时间持有锁导致阻塞。
   - 乐观锁需合理设置重试次数（避免无限重试），并确保版本号字段有索引。

实际开发中，可根据业务压力动态调整，甚至混合使用（如“热点商品用悲观锁+普通商品用乐观锁”），在数据一致性与系统性能间取得平衡。